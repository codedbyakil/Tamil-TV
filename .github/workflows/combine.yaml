name: Build main.m3u (Tamil + Zee + Local) with Channel Numbers & Sorting

on:
  workflow_run:
    workflows: ["Auto-Update Tamil M3U"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Verify files
        run: |
          for f in tamil.m3u zee.m3u local.m3u; do
            [ -f "$f" ] || { echo "‚ùå $f missing"; exit 1; }
          done
          echo "‚úÖ All files present."

      - name: Normalize files
        run: |
          sudo apt-get update && sudo apt-get install -y dos2unix
          for f in tamil.m3u zee.m3u local.m3u; do
            sed -i '1s/^\xEF\xBB\xBF//' "$f"
            dos2unix "$f" 2>/dev/null || sed -i 's/\r$//' "$f"
            sed -i 's/[ \t]*$//' "$f"
          done

      - name: Build main.m3u with sorting & numbering
        run: |
          OUTPUT="main.m3u"
          echo "#EXTM3U x-tvg-url=\"https://iptv-org.github.io/epg/guides/tamil.xml\"" > "$OUTPUT"

          # === 1. Extract ALL Tamil-category channels (from tamil.m3u + zee.m3u) ===
          echo "# === Tamil Channels (Sorted & Numbered) ===" >> "$OUTPUT"

          # Create temp files
          TMP_DIR=$(mktemp -d)
          TAMIL_RAW="$TMP_DIR/tamil_raw.txt"
          ZEE_RAW="$TMP_DIR/zee_raw.txt"
          ALL_TAMIL="$TMP_DIR/all_tamil.txt"

          # Extract blocks from tamil.m3u (skip #EXTM3U)
          awk '
            /^#EXTM3U/ { next }
            /^#EXTINF/ {
              block = $0 "\n"; in_block = 1; next;
            }
            in_block && NF == 0 { next }  # skip blank lines inside?
            in_block {
              block = block $0 "\n";
              if (/^[ \t]*http/) in_block = 0;
            }
            !in_block && block != "" {
              print "---CHANNEL---";
              printf "%s", block;
              block = "";
            }
            END { if (block != "") { print "---CHANNEL---"; printf "%s", block; } }
          ' tamil.m3u > "$TAMIL_RAW"

          # Extract blocks from zee.m3u
          awk '
            /^#EXTINF/ {
              block = $0 "\n"; in_block = 1; next;
            }
            in_block && NF == 0 { next }
            in_block {
              block = block $0 "\n";
              if (/^[ \t]*http/) in_block = 0;
            }
            !in_block && block != "" {
              print "---CHANNEL---";
              printf "%s", block;
              block = "";
            }
            END { if (block != "") { print "---CHANNEL---"; printf "%s", block; } }
          ' zee.m3u > "$ZEE_RAW"

          # Combine
          cat "$TAMIL_RAW" "$ZEE_RAW" > "$ALL_TAMIL"

          # === 2. Define priority list (normalized) ===
          # We'll match using: lower, trim, remove "hd", "tamil", "tamil hd", etc.
          cat > "$TMP_DIR/priority.txt" <<'EOF'
sun tv
ktv
star vijay
zee tamil
colors tamil
polimer tv
kalaignar tv
vijay super
zee thirai
sun life
adithya tv
sun music
jaya tv
jaya plus
jaya max
j movies
raj tv
vasanth tv
d tamil
history hd
disney
hungama
cartoon network
pogo
sonic
disney junior
super hungama
discovery kids
EOF

          # === 3. Sort & Number Tamil Channels ===
          # Script to parse, normalize name, match priority, assign number
          awk -v priority_file="$TMP_DIR/priority.txt" '
            BEGIN {
              # Load priority list
              prio_count = 0;
              while ((getline line < priority_file) > 0) {
                gsub(/^[ \t]+|[ \t]+$/, "", line);
                line = tolower(line);
                prio[line] = ++prio_count;
              }
              close(priority_file);
            }

            /^---CHANNEL---/ {
              if (block != "") process_block(block);
              block = "";
              next;
            }
            { block = (block == "" ? $0 : block "\n" $0); }
            END { if (block != "") process_block(block); }

            function normalize_name(extinf_line,    name_part, clean) {
              # Extract display name: after last comma
              match(extinf_line, /,[^,]*$/);
              if (RSTART > 0) {
                name_part = substr(extinf_line, RSTART + 1);
              } else {
                name_part = "Unknown";
              }
              gsub(/^[ \t"'\''"]+|[ \t"'\''"]+$/, "", name_part);
              # Normalize: lower, remove HD/Tamil/etc.
              clean = tolower(name_part);
              gsub(/ hd$/, "", clean);
              gsub(/ hd | hd$/, " ", clean);
              gsub(/ tamil$/, "", clean);
              gsub(/ tamil hd$/, "", clean);
              gsub(/ tv hd$/, " tv", clean);
              gsub(/ tv$/, "", clean);  # optional: keep "tv" for disambiguation?
              gsub(/  +/, " ", clean);
              gsub(/^[ \t]+|[ \t]+$/, "", clean);
              return clean;
            }

            function process_block(blk,    lines, n, extinf_idx, extinf_line, norm_name, prio_rank, new_extinf, name_part, url) {
              n = split(blk, lines, /\n/);
              extinf_idx = -1;
              for (i = 1; i <= n; i++) {
                if (lines[i] ~ /^#EXTINF:/) {
                  extinf_idx = i;
                  extinf_line = lines[i];
                  break;
                }
              }
              if (extinf_idx == -1) return;

              norm_name = normalize_name(extinf_line);
              prio_rank = prio[norm_name];

              # Extract original name for display (before comma)
              match(extinf_line, /,[^,]*$/);
              if (RSTART > 0) {
                prefix = substr(extinf_line, 1, RSTART - 1);
                name_part = substr(extinf_line, RSTART + 1);
                gsub(/^[ \t"'\''"]+|[ \t"'\''"]+$/, "", name_part);
              } else {
                prefix = extinf_line;
                name_part = "Unknown";
              }

              # Assign channel number later (we need full list first)
              # Store: [prio_rank, norm_name, original_name, extinf_prefix, full_block]
              blocks[++block_count] = prio_rank SUBSEP norm_name SUBSEP name_part SUBSEP prefix SUBSEP blk;
            }
          ' "$ALL_TAMIL" > "$TMP_DIR/unsorted_tamil.txt"

          # Now sort & assign numbers
          awk '
            BEGIN {
              FS = SUBSEP;
              block_count = 0;
            }
            {
              blocks[++block_count] = $0;
              ranks[block_count] = ($1 == "") ? 9999 : ($1 + 0);
              names[block_count] = $2;
            }
            END {
              # Sort by rank (numeric), then by norm_name
              for (i = 1; i <= block_count; i++) {
                for (j = i + 1; j <= block_count; j++) {
                  if (ranks[i] > ranks[j] || (ranks[i] == ranks[j] && names[i] > names[j])) {
                    # swap
                    tmp = blocks[i]; blocks[i] = blocks[j]; blocks[j] = tmp;
                    tmp = ranks[i]; ranks[i] = ranks[j]; ranks[j] = tmp;
                    tmp = names[i]; names[i] = names[j]; names[j] = tmp;
                  }
                }
              }

              chno = 1;
              for (i = 1; i <= block_count; i++) {
                split(blocks[i], f, SUBSEP);
                prio_rank = f[1];
                norm_name = f[2];
                orig_name = f[3];
                prefix = f[4];
                blk = f[5];

                # Rebuild #EXTINF: inject tvg-chno and optionally prepend "#N "
                # Remove existing tvg-chno if any
                gsub(/tvg-chno="[^"]*"/, "", prefix);
                gsub(/tvg-chno=[^, \t]*/, "", prefix);
                # Ensure space before comma
                gsub(/ +,/, ",", prefix);

                # Option A: prepend "#1 " to display name (visible in players)
                # new_name = "#" chno " " orig_name;
                # Option B: only use tvg-chno (cleaner)
                new_name = orig_name;

                new_extinf = prefix " tvg-chno=\"" chno "\"";
                # Insert before comma
                if (match(new_extinf, /,[^,]*$/)) {
                  pre = substr(new_extinf, 1, RSTART - 1);
                  suf = substr(new_extinf, RSTART);
                  new_extinf = pre suf;
                } else {
                  new_extinf = new_extinf ",";
                }
                # Fix double comma or missing comma
                gsub(/, +,/, ",", new_extinf);
                if (new_extinf !~ /,/) new_extinf = new_extinf ",";
                # Ensure exactly one comma before name
                new_extinf = gensub(/(.*),[^,]*$/, "\\1," new_name, 1, new_extinf);

                # Replace old EXTINF with new one
                gsub(/^#EXTINF:[^\n]*/, new_extinf, blk);
                printf "%s\n", blk;

                chno++;
              }
            }
          ' "$TMP_DIR/unsorted_tamil.txt" >> "$OUTPUT"

          # === 4. Process local.m3u ‚Üí sort alphabetically by channel name ===
          echo "" >> "$OUTPUT"
          echo "# === Local Channels (A‚ÜíZ) ===" >> "$OUTPUT"

          awk '
            BEGIN { block = ""; chno = 1; }
            /^#EXTINF/ {
              if (block != "") blocks[block_count++] = block;
              block = $0 "\n"; next;
            }
            block != "" {
              block = block $0 "\n";
              if (/^[ \t]*http/) {
                blocks[block_count++] = block;
                block = "";
              }
            }
            END { if (block != "") blocks[block_count++] = block; }

            function get_name(extinf,    name_part) {
              match(extinf, /,[^,]*$/);
              if (RSTART > 0) {
                name_part = substr(extinf, RSTART + 1);
                gsub(/^[ \t"'\''"]+|[ \t"'\''"]+$/, "", name_part);
                return tolower(name_part);
              }
              return "zzz";
            }

            END {
              # Extract names and sort indices
              for (i = 0; i < block_count; i++) {
                match(blocks[i], /^#EXTINF:[^\n]*/);
                extinf = substr(blocks[i], 1, RLENGTH);
                names[i] = get_name(extinf);
                idx[i] = i;
              }
              # Simple bubble sort by name
              for (i = 0; i < block_count; i++) {
                for (j = i + 1; j < block_count; j++) {
                  if (names[idx[i]] > names[idx[j]]) {
                    tmp = idx[i]; idx[i] = idx[j]; idx[j] = tmp;
                  }
                }
              }
              for (i = 0; i < block_count; i++) {
                blk = blocks[idx[i]];
                # Inject tvg-chno (optional, e.g., L1, L2‚Ä¶ or just skip)
                match(blk, /^#EXTINF:[^\n]*/);
                extinf = substr(blk, 1, RLENGTH);
                gsub(/tvg-chno="[^"]*"/, "", extinf);
                gsub(/tvg-chno=[^, \t]*/, "", extinf);
                gsub(/ +,/, ",", extinf);
                new_extinf = extinf " tvg-chno=\"L" chno "\"";
                if (match(new_extinf, /,[^,]*$/)) {
                  pre = substr(new_extinf, 1, RSTART - 1);
                  suf = substr(new_extinf, RSTART);
                  new_extinf = pre suf;
                } else {
                  new_extinf = new_extinf ",";
                }
                gsub(/^#EXTINF:[^\n]*/, new_extinf, blk);
                printf "%s", blk;
                chno++;
              }
            }
          ' local.m3u >> "$OUTPUT"

          # === Stats ===
          TAMIL=$(awk '/group-title="Tamil"/ && /^#EXTINF/ { c++ } END { print c+0 }' "$OUTPUT")
          LOCAL=$(awk '/group-title="Local Channels"/ && /^#EXTINF/ { c++ } END { print c+0 }' "$OUTPUT")
          echo "‚úÖ main.m3u built:"
          echo "   üì∫ Tamil (numbered & sorted): $TAMIL"
          echo "   üì∫ Local (A‚ÜíZ sorted): $LOCAL"

          # Cleanup
          rm -rf "$TMP_DIR"

      - name: Commit main.m3u
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add main.m3u
          if git diff --cached --quiet; then
            echo "‚û°Ô∏è No changes ‚Äî skipping commit"
            exit 0
          fi
          TAMIL=$(awk '/group-title="Tamil"/ && /^#EXTINF/ { c++ } END { print c+0 }' main.m3u)
          LOCAL=$(awk '/group-title="Local Channels"/ && /^#EXTINF/ { c++ } END { print c+0 }' main.m3u)
          git commit -m "üì∫ main.m3u: $TAMIL Tamil (#1‚Äì#${TAMIL}) + $LOCAL Local (A‚ÜíZ)"
          git push origin main
